{
    "docs": [
        {
            "location": "/",
            "text": "Unofficial Monero Documentation (1% done)\n\n\nMonerodocs attempts to organize basic technical knowledge on Monero in one place.\n\n\nThe goal is to educate and onboard power users faster.\n\n\nWhile technical explanations are out there, the information is scattered through reddit posts, git comments, stack exchange answers, chat logs and the source code.\n\n\nThis makes it hard to find complete and up-to-date explanations on advanced topics.\n\n\nIf you spot errors or issues please kindly drop me an email at \nqertoip@gmail.com\n or submit a github pull request.",
            "title": "Home"
        },
        {
            "location": "/#unofficial-monero-documentation-1-done",
            "text": "Monerodocs attempts to organize basic technical knowledge on Monero in one place.  The goal is to educate and onboard power users faster.  While technical explanations are out there, the information is scattered through reddit posts, git comments, stack exchange answers, chat logs and the source code.  This makes it hard to find complete and up-to-date explanations on advanced topics.  If you spot errors or issues please kindly drop me an email at  qertoip@gmail.com  or submit a github pull request.",
            "title": "Unofficial Monero Documentation (1% done)"
        },
        {
            "location": "/interacting/overview/",
            "text": "Interacting with Monero\n\n\nYou can interact with Monero via desktop GUI, commandline interface, and programming API.\n\n\nOn top of that, Monero nodes interact with each other in a peer-to-peer network. \n\n\nInstallation directory overview\n\n\nThis considers the released version of Monero software. Once unpacked, you will notice six executable files:\n\n\n\n\nSeparation of node and wallet\n\n\nMonero project nicely decouples node logic \nmonerod\n from wallet logic \nmonero-wallet-*\n.\nWallet logic is offered through three independent user interfaces - the GUI, the CLI, and the HTTP API.\n\n\n\n\n\n\n\n\nExecutable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmonerod\n\n\nThe full node daemon. Does not require a wallet.\n\n\n\n\n\n\nmonero-wallet-gui\n\n\nWallet logic and \ngraphical\n user interface. Requires \nmonerod\n running.\n\n\n\n\n\n\nmonero-wallet-cli\n\n\nWallet logic and \ncommandline\n user interface. Requires \nmonerod\n running.\n\n\n\n\n\n\nmonero-wallet-rpc\n\n\nWallet logic and \nHTTP API\n (JSON-RPC protocol). Requires \nmonerod\n running.\n\n\n\n\n\n\nmonero-blockchain-export\n\n\nTool to export blockchain to \nblockchain.raw\n file.\n\n\n\n\n\n\nmonero-blockchain-import\n\n\nTool to import \nblockchain.raw\n - ideally your own trusted copy.\n\n\n\n\n\n\n\n\nInteracting\n\n\nThere are quite a few ways you can interact with Monero software.\nPerhaps the most surprising for newcomers is that \nmonerod\n daemon accepts interactive keyboard commands while it is running.\n\n\nAlso, please note that HTTP API is split across \nmonerod\n and \nmonero-wallet-rpc\n. You need to run and call both daemons to explore the full API.\nThis follows the node-logic vs wallet-logic split mentioned earlier.   \n\n\nAll wallet implementations depend on the \nmonerod\n running.\n\n\n\n\n\n\n\n\nExecutable\n\n\np2p network\n\n\nnode commands via keyboard\n\n\nnode HTTP API\n\n\nwallet commands via keyboard\n\n\nwallet HTTP API\n\n\nwallet via GUI\n\n\n\n\n\n\n\n\n\n\nmonerod\n\n\n\u2714\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\n\n\n\n\n\n\nmonero-wallet-cli\n\n\n\n\n\n\n\n\n\u2714\n\n\n\n\n\n\n\n\n\n\nmonero-wallet-rpc\n\n\n\n\n\n\n\n\n\n\n\u2714\n\n\n\n\n\n\n\n\nmonero-wallet-gui\n\n\n\n\n\n\n\n\n\n\n\n\n\u2714",
            "title": "Interacting"
        },
        {
            "location": "/interacting/overview/#interacting-with-monero",
            "text": "You can interact with Monero via desktop GUI, commandline interface, and programming API.  On top of that, Monero nodes interact with each other in a peer-to-peer network.",
            "title": "Interacting with Monero"
        },
        {
            "location": "/interacting/overview/#installation-directory-overview",
            "text": "This considers the released version of Monero software. Once unpacked, you will notice six executable files:",
            "title": "Installation directory overview"
        },
        {
            "location": "/interacting/overview/#separation-of-node-and-wallet",
            "text": "Monero project nicely decouples node logic  monerod  from wallet logic  monero-wallet-* .\nWallet logic is offered through three independent user interfaces - the GUI, the CLI, and the HTTP API.     Executable  Description      monerod  The full node daemon. Does not require a wallet.    monero-wallet-gui  Wallet logic and  graphical  user interface. Requires  monerod  running.    monero-wallet-cli  Wallet logic and  commandline  user interface. Requires  monerod  running.    monero-wallet-rpc  Wallet logic and  HTTP API  (JSON-RPC protocol). Requires  monerod  running.    monero-blockchain-export  Tool to export blockchain to  blockchain.raw  file.    monero-blockchain-import  Tool to import  blockchain.raw  - ideally your own trusted copy.",
            "title": "Separation of node and wallet"
        },
        {
            "location": "/interacting/overview/#interacting",
            "text": "There are quite a few ways you can interact with Monero software.\nPerhaps the most surprising for newcomers is that  monerod  daemon accepts interactive keyboard commands while it is running.  Also, please note that HTTP API is split across  monerod  and  monero-wallet-rpc . You need to run and call both daemons to explore the full API.\nThis follows the node-logic vs wallet-logic split mentioned earlier.     All wallet implementations depend on the  monerod  running.     Executable  p2p network  node commands via keyboard  node HTTP API  wallet commands via keyboard  wallet HTTP API  wallet via GUI      monerod  \u2714  \u2714  \u2714       monero-wallet-cli     \u2714      monero-wallet-rpc      \u2714     monero-wallet-gui       \u2714",
            "title": "Interacting"
        },
        {
            "location": "/technical-specs/",
            "text": "Monero Technical Specs\n\n\nLive\n\n\n\n\nMonero blockchain is live since 18 April 2014\n\n\n\n\nNo premine, no instamine, no ICO/token\n\n\n\n\nMonero had no premine or instamine\n\n\nMonero did not sell any token\n\n\nMonero had no presale of any kind\n\n\n\n\nProof of Work\n\n\n\n\nCryptoNight\n\n\nmay change in the future\n\n\n\n\nDifficulty retarget\n\n\n\n\nevery block\n\n\nbased on the last 720 blocks, excluding 20% of the timestamp outliers\n\n\n\n\nBlock time\n\n\n\n\n2 minutes\n\n\nmay change in the future as long as emission curve is preserved\n\n\n\n\nBlock reward\n\n\n\n\n~6 XMR as of Dec 2017, see the \nlatest block\n coinbase transaction amount for current reward\n\n\nsmoothly decreasing and subject to penalties for blocks greater then median size of the last 100 blocks (M100)\n\n\n\n\nBlock size\n\n\n\n\ndynamic, maximum of two times median size of the last 100 blocks (2 * M100)\n\n\n\n\nEmission curve\n\n\nMain emission\n\n\nFirst, the main emission is about to produce ~18.132 million coins by the end of May 2022.\n\n\nAs of Dec 2017 the emission is about 30 XMR per 10 minutes.\n\n\nSee \ncharts and details\n.\n\n\nTail emission\n\n\nThe tail emission kicks in once main emission is done.\n\n\nIt will produce 0.6 XMR per 2-minute block.\n\n\nThis translates to <1% inflation decreasing over time.\n\n\nMax supply\n\n\n\n\ninfinite\n\n\n\n\nSender privacy\n\n\n\n\nRing signatures\n\n\n\n\nRecipient privacy\n\n\n\n\nStealth addresses\n\n\n\n\nAmount privacy\n\n\n\n\nRing confidential transactions\n\n\n\n\nIP address privacy\n\n\n\n\nnot built in\n\n\nuse TOR or I2P\n\n\nthere is an ongoing effort to integrate I2P into Monero: the Kovri project",
            "title": "Technical Specs"
        },
        {
            "location": "/technical-specs/#monero-technical-specs",
            "text": "",
            "title": "Monero Technical Specs"
        },
        {
            "location": "/technical-specs/#live",
            "text": "Monero blockchain is live since 18 April 2014",
            "title": "Live"
        },
        {
            "location": "/technical-specs/#no-premine-no-instamine-no-icotoken",
            "text": "Monero had no premine or instamine  Monero did not sell any token  Monero had no presale of any kind",
            "title": "No premine, no instamine, no ICO/token"
        },
        {
            "location": "/technical-specs/#proof-of-work",
            "text": "CryptoNight  may change in the future",
            "title": "Proof of Work"
        },
        {
            "location": "/technical-specs/#difficulty-retarget",
            "text": "every block  based on the last 720 blocks, excluding 20% of the timestamp outliers",
            "title": "Difficulty retarget"
        },
        {
            "location": "/technical-specs/#block-time",
            "text": "2 minutes  may change in the future as long as emission curve is preserved",
            "title": "Block time"
        },
        {
            "location": "/technical-specs/#block-reward",
            "text": "~6 XMR as of Dec 2017, see the  latest block  coinbase transaction amount for current reward  smoothly decreasing and subject to penalties for blocks greater then median size of the last 100 blocks (M100)",
            "title": "Block reward"
        },
        {
            "location": "/technical-specs/#block-size",
            "text": "dynamic, maximum of two times median size of the last 100 blocks (2 * M100)",
            "title": "Block size"
        },
        {
            "location": "/technical-specs/#emission-curve",
            "text": "Main emission  First, the main emission is about to produce ~18.132 million coins by the end of May 2022.  As of Dec 2017 the emission is about 30 XMR per 10 minutes.  See  charts and details .  Tail emission  The tail emission kicks in once main emission is done.  It will produce 0.6 XMR per 2-minute block.  This translates to <1% inflation decreasing over time.",
            "title": "Emission curve"
        },
        {
            "location": "/technical-specs/#max-supply",
            "text": "infinite",
            "title": "Max supply"
        },
        {
            "location": "/technical-specs/#sender-privacy",
            "text": "Ring signatures",
            "title": "Sender privacy"
        },
        {
            "location": "/technical-specs/#recipient-privacy",
            "text": "Stealth addresses",
            "title": "Recipient privacy"
        },
        {
            "location": "/technical-specs/#amount-privacy",
            "text": "Ring confidential transactions",
            "title": "Amount privacy"
        },
        {
            "location": "/technical-specs/#ip-address-privacy",
            "text": "not built in  use TOR or I2P  there is an ongoing effort to integrate I2P into Monero: the Kovri project",
            "title": "IP address privacy"
        },
        {
            "location": "/primitives/base58/",
            "text": "Base58\n\n\nBase58 is a binary-to-text encoding scheme. It is similar to Base64 but has been modified to avoid both non-alphanumeric characters and letters which might look ambiguous when printed. The characters excluded in relation to Base64 are: \nIOl0+/\n\n\nBase58 does not strictly specify the format. This results in some implementations being incompatible with others, for example with regard to alphabet order.\n\n\nFor details, see \nWikipedia\n.\n\n\nBase58 in Monero\n\n\nMonero has its own variant of Base58.\n\n\nIn Monero the Base58 encoding is performed in 8-byte blocks, except the last block which is the remaining (8 or less) bytes .\n\n\nThe 8-byte block converts to 11 or less Base58 characters. If the block converted to less then 11 characters, the output is padded with \"1\"s (0 in Base58). The final block is padded as well to whatever would be the maximum size of this number of bytes encoded in Base58.\n\n\nThe advantage of Monero implementation is that output is of a fixed size which is not the case with plain Base58. The disadvantage is that default libraries won't work.\n\n\nFor details, see \nreference C++ Base58\n implementation and \nunofficial Python Base58\n implementation.",
            "title": "Base58"
        },
        {
            "location": "/primitives/base58/#base58",
            "text": "Base58 is a binary-to-text encoding scheme. It is similar to Base64 but has been modified to avoid both non-alphanumeric characters and letters which might look ambiguous when printed. The characters excluded in relation to Base64 are:  IOl0+/  Base58 does not strictly specify the format. This results in some implementations being incompatible with others, for example with regard to alphabet order.  For details, see  Wikipedia .",
            "title": "Base58"
        },
        {
            "location": "/primitives/base58/#base58-in-monero",
            "text": "Monero has its own variant of Base58.  In Monero the Base58 encoding is performed in 8-byte blocks, except the last block which is the remaining (8 or less) bytes .  The 8-byte block converts to 11 or less Base58 characters. If the block converted to less then 11 characters, the output is padded with \"1\"s (0 in Base58). The final block is padded as well to whatever would be the maximum size of this number of bytes encoded in Base58.  The advantage of Monero implementation is that output is of a fixed size which is not the case with plain Base58. The disadvantage is that default libraries won't work.  For details, see  reference C++ Base58  implementation and  unofficial Python Base58  implementation.",
            "title": "Base58 in Monero"
        },
        {
            "location": "/cryptography/overview/",
            "text": "Monero cryptography overview\n\n\nMonero uses a wide variety of cryptographic primitives for various use cases.\n\n\nComparing to altcoins, Monero cryptography is considered conservative, sound and robust.\n\n\nComparing to Bitcoin, Monero uses much more primitives, and some of them are more advanced, especially those related to privacy and Proof of Work.\nSome choices are deliberately non-standard (for better or worse) - oftentimes a legacy of the CryptoNote protocol.",
            "title": "Overview"
        },
        {
            "location": "/cryptography/overview/#monero-cryptography-overview",
            "text": "Monero uses a wide variety of cryptographic primitives for various use cases.  Comparing to altcoins, Monero cryptography is considered conservative, sound and robust.  Comparing to Bitcoin, Monero uses much more primitives, and some of them are more advanced, especially those related to privacy and Proof of Work.\nSome choices are deliberately non-standard (for better or worse) - oftentimes a legacy of the CryptoNote protocol.",
            "title": "Monero cryptography overview"
        },
        {
            "location": "/cryptography/prng/",
            "text": "Monero Pseudo Random Number Generator\n\n\nMonero uses PRNG based on Keccak hashing function.\n\n\nThe seed comes from entropy sources provided by operating system.\nOn Linux and MacOS this translates to \n/dev/urandom\n.\nOn Windows the WinAPI \nCryptGenRandom\n call is used.\n\n\nThere is no reseeding.\n\n\nCaveats\n\n\n\n\nIn Monero source code you can also find libsodium based random bytes generator. It is part of the embedded library and apparently is not used in actual Monero code.  \n\n\n\n\nReference\n\n\n\n\nSource code\n\n\nStackExchange answer",
            "title": "PRNG"
        },
        {
            "location": "/cryptography/prng/#monero-pseudo-random-number-generator",
            "text": "Monero uses PRNG based on Keccak hashing function.  The seed comes from entropy sources provided by operating system.\nOn Linux and MacOS this translates to  /dev/urandom .\nOn Windows the WinAPI  CryptGenRandom  call is used.  There is no reseeding.",
            "title": "Monero Pseudo Random Number Generator"
        },
        {
            "location": "/cryptography/prng/#caveats",
            "text": "In Monero source code you can also find libsodium based random bytes generator. It is part of the embedded library and apparently is not used in actual Monero code.",
            "title": "Caveats"
        },
        {
            "location": "/cryptography/prng/#reference",
            "text": "Source code  StackExchange answer",
            "title": "Reference"
        },
        {
            "location": "/cryptography/keccak-256/",
            "text": "Keccak-256 hash function\n\n\nMonero employs Keccak-256 as a hashing function.\n\n\nKeccak is the leading hashing function, designed by non-NSA designers.\nKeccak won \nNIST competition\n to become the official SHA3.\n\n\nUses\n\n\nMonero does \nnot\n employ Keccak for Proof-of-Work. Instead, Keccak is used for:\n\n\n\n\nrandom number generator\n\n\nblock hashing\n\n\ntransaction hashing\n\n\nstealth address private key image (for double spend protection)\n\n\npublic address checksum\n\n\nRingCT\n\n\nmultisig\n\n\nbulletproofs\n\n\n\n\n...and likely a few other things.\n\n\nKeccak-256 vs SHA3-256\n\n\nSHA3-256 is Keccak-256, except NIST changed padding.\nFor that reason original Keccak-256 gives in a different hash value than NIST SHA3-256.  \n\n\nMonero uses original Keccak-256.\nThe NIST standard was only published on August 2015, while Monero went live on 18 April 2014.  \n\n\nReference\n\n\n\n\nKeccak source code used in Monero\n\n\nSHA3 on Wikipedia\n\n\nKeccak-256 vs SHA3-256\n explained on Ethereum stackexchange\n\n\nOnline tool to calculate Keccak-256 and SHA3-256",
            "title": "Keccak-256"
        },
        {
            "location": "/cryptography/keccak-256/#keccak-256-hash-function",
            "text": "Monero employs Keccak-256 as a hashing function.  Keccak is the leading hashing function, designed by non-NSA designers.\nKeccak won  NIST competition  to become the official SHA3.",
            "title": "Keccak-256 hash function"
        },
        {
            "location": "/cryptography/keccak-256/#uses",
            "text": "Monero does  not  employ Keccak for Proof-of-Work. Instead, Keccak is used for:   random number generator  block hashing  transaction hashing  stealth address private key image (for double spend protection)  public address checksum  RingCT  multisig  bulletproofs   ...and likely a few other things.",
            "title": "Uses"
        },
        {
            "location": "/cryptography/keccak-256/#keccak-256-vs-sha3-256",
            "text": "SHA3-256 is Keccak-256, except NIST changed padding.\nFor that reason original Keccak-256 gives in a different hash value than NIST SHA3-256.    Monero uses original Keccak-256.\nThe NIST standard was only published on August 2015, while Monero went live on 18 April 2014.",
            "title": "Keccak-256 vs SHA3-256"
        },
        {
            "location": "/cryptography/keccak-256/#reference",
            "text": "Keccak source code used in Monero  SHA3 on Wikipedia  Keccak-256 vs SHA3-256  explained on Ethereum stackexchange  Online tool to calculate Keccak-256 and SHA3-256",
            "title": "Reference"
        },
        {
            "location": "/public-address/standard-address/",
            "text": "Address\n\n\nMonero public address is what you publish to get paid.\n\n\nAn address can be generated offline and for free. It boils down to generating a large random number representing your private spending key.\n\n\nPublishing your Monero address does \nnot\n endanger your privacy. That's because in Monero transactions go to stealth addresses which are decoupled from your public address.\n\n\nThere are a few types of public addresses in Monero:\n\n\n\n\nStandard address - the basic type of the address, also refered to as raw address\n\n\nIntegrated address - embeds payment ID so you can learn for what you are being paid\n\n\nSubaddress - slightly enhances privacy and allows for organizing your funds in subaccounts within a single wallet\n\n\n\n\nStandard address\n\n\nThe raw address is useful for things like donations (where you don't care who donated)\nor exchange withdrawals (where you know the payer out of band). Its strength is simplicity.\n\n\nMonero standard address is composed of two public keys:\n\n\n\n\npublic spend key\n\n\npublic view key\n\n\n\n\nIt also contains a checksum and a \"network byte\" which actually identifies both the network and the address type.\n\n\nData structure (\nsrc\n):\n\n\n\n\n\n\n\n\nIndex\n\n\nSize in bytes\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\nidentifies the network and address type; \n18\n - main chain; \n53\n - test chain\n\n\n\n\n\n\n1\n\n\n32\n\n\npublic spend key\n\n\n\n\n\n\n33\n\n\n32\n\n\npublic view key\n\n\n\n\n\n\n65\n\n\n4\n\n\nchecksum (\nKeccak-f[1600] hash\n of the previous 65 bytes, trimmed to first \n4\n bytes)\n\n\n\n\n\n\n\n\nIt totals to 69 bytes. The bytes are then encoded (\nsrc\n) in \nMonero specific Base58\n format, resulting in a 95 chars long string. Example standard address:\n\n\n4AdUndXHHZ6cfufTMvppY6JwXNouMBzSkbLYfpAV5Usx3skxNgYeYTRj5UzqtReoS44qo9mtmXCqY45DJ852K5Jv2684Rge\n\n\nReference\n\n\n\n\nhttps://xmr.llcoins.net/addresstests.html",
            "title": "Standard"
        },
        {
            "location": "/public-address/standard-address/#address",
            "text": "Monero public address is what you publish to get paid.  An address can be generated offline and for free. It boils down to generating a large random number representing your private spending key.  Publishing your Monero address does  not  endanger your privacy. That's because in Monero transactions go to stealth addresses which are decoupled from your public address.  There are a few types of public addresses in Monero:   Standard address - the basic type of the address, also refered to as raw address  Integrated address - embeds payment ID so you can learn for what you are being paid  Subaddress - slightly enhances privacy and allows for organizing your funds in subaccounts within a single wallet",
            "title": "Address"
        },
        {
            "location": "/public-address/standard-address/#standard-address",
            "text": "The raw address is useful for things like donations (where you don't care who donated)\nor exchange withdrawals (where you know the payer out of band). Its strength is simplicity.  Monero standard address is composed of two public keys:   public spend key  public view key   It also contains a checksum and a \"network byte\" which actually identifies both the network and the address type.  Data structure ( src ):     Index  Size in bytes  Description      0  1  identifies the network and address type;  18  - main chain;  53  - test chain    1  32  public spend key    33  32  public view key    65  4  checksum ( Keccak-f[1600] hash  of the previous 65 bytes, trimmed to first  4  bytes)     It totals to 69 bytes. The bytes are then encoded ( src ) in  Monero specific Base58  format, resulting in a 95 chars long string. Example standard address:  4AdUndXHHZ6cfufTMvppY6JwXNouMBzSkbLYfpAV5Usx3skxNgYeYTRj5UzqtReoS44qo9mtmXCqY45DJ852K5Jv2684Rge",
            "title": "Standard address"
        },
        {
            "location": "/public-address/standard-address/#reference",
            "text": "https://xmr.llcoins.net/addresstests.html",
            "title": "Reference"
        },
        {
            "location": "/public-address/integrated-address/",
            "text": "Integrated address\n\n\nMonero integrated address embeds a compact payment ID.\n\n\nUse integrated address to learn for what you are being paid. It is ideal for accepting Monero in an automated fashion,\nlike online stores and exchanges.    \n\n\nYou should allow Monero software to generate integrated addresses for you (instead of forcing your own payment IDs).\nPlease note these are Monero technical payment IDs and must not be confused with business identifiers like order number or invoice number.\n\n\nThe transaction to integrated address will not reveal the payment ID publicly.\nPayment ID in a transaction will be encrypted with a shared secret (one-time random key known only to sender and recipient).\nOnly the recipient will be able to match the transaction against payment ID.\nTODO: explain how exactly payment IDs are encoded in transactions.\n\n\nMonero integrated address obsoletes the former practice of using full 32-bytes payment ID in a transaction extra field (where it was not encrypted).\n\n\nData structure (\nsrc\n):\n\n\n\n\n\n\n\n\nIndex\n\n\nSize in bytes\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\nidentifies the network and address type; \n19\n - main chain; \n54\n - test chain\n\n\n\n\n\n\n1\n\n\n32\n\n\npublic spend key\n\n\n\n\n\n\n33\n\n\n32\n\n\npublic view key\n\n\n\n\n\n\n65\n\n\n8\n\n\ncompact payment ID -  8 bytes randomly generated by the recipient; note that it does not need encryption in the address itself but it is hidden in a transaction paying to integrated address to prevent linking payment with the address by external observers\n\n\n\n\n\n\n73\n\n\n4\n\n\nchecksum (\nKeccak-f[1600] hash\n of the previous 73 bytes, trimmed to first \n4\n bytes)\n\n\n\n\n\n\n\n\nIt totals to 78 bytes. The bytes are then encoded (\nsrc\n) in \nMonero specific Base58\n format, resulting in a 106 chars long string. Example integrated address:\n\n\n4LL9oSLmtpccfufTMvppY6JwXNouMBzSkbLYfpAV5Usx3skxNgYeYTRj5UzqtReoS44qo9mtmXCqY45DJ852K5Jv2bYXZKKQePHES9khPK\n\n\nCaveats\n\n\nSingle transaction cannot pay to multiple integrated addresses.\n\n\nReference\n\n\n\n\nquestion on \nStackExchenge",
            "title": "Integrated"
        },
        {
            "location": "/public-address/integrated-address/#integrated-address",
            "text": "Monero integrated address embeds a compact payment ID.  Use integrated address to learn for what you are being paid. It is ideal for accepting Monero in an automated fashion,\nlike online stores and exchanges.      You should allow Monero software to generate integrated addresses for you (instead of forcing your own payment IDs).\nPlease note these are Monero technical payment IDs and must not be confused with business identifiers like order number or invoice number.  The transaction to integrated address will not reveal the payment ID publicly.\nPayment ID in a transaction will be encrypted with a shared secret (one-time random key known only to sender and recipient).\nOnly the recipient will be able to match the transaction against payment ID.\nTODO: explain how exactly payment IDs are encoded in transactions.  Monero integrated address obsoletes the former practice of using full 32-bytes payment ID in a transaction extra field (where it was not encrypted).  Data structure ( src ):     Index  Size in bytes  Description      0  1  identifies the network and address type;  19  - main chain;  54  - test chain    1  32  public spend key    33  32  public view key    65  8  compact payment ID -  8 bytes randomly generated by the recipient; note that it does not need encryption in the address itself but it is hidden in a transaction paying to integrated address to prevent linking payment with the address by external observers    73  4  checksum ( Keccak-f[1600] hash  of the previous 73 bytes, trimmed to first  4  bytes)     It totals to 78 bytes. The bytes are then encoded ( src ) in  Monero specific Base58  format, resulting in a 106 chars long string. Example integrated address:  4LL9oSLmtpccfufTMvppY6JwXNouMBzSkbLYfpAV5Usx3skxNgYeYTRj5UzqtReoS44qo9mtmXCqY45DJ852K5Jv2bYXZKKQePHES9khPK",
            "title": "Integrated address"
        },
        {
            "location": "/public-address/integrated-address/#caveats",
            "text": "Single transaction cannot pay to multiple integrated addresses.",
            "title": "Caveats"
        },
        {
            "location": "/public-address/integrated-address/#reference",
            "text": "question on  StackExchenge",
            "title": "Reference"
        },
        {
            "location": "/public-address/subaddress/",
            "text": "Subaddress\n\n\n!! This is unreleased feature !!\n\n\nSubaddresses serve two purposes described below.\n\n\nPrevent payer from linking your payouts together\n\n\nTo prevent the payer from linking your payouts together simply generate a new subaddress for each payout.\nThis way services like \nShapeshift\n wouldn't know it is you again receving Monero.\n\n\nNote it won't help if you have an account with the service. Then your payouts are already linked in the service database, regardless of Monero.\n\n\nGroup incoming payments\n\n\nThink income streams.\n\n\nSubaddresses allow to group incoming transactions within a single wallet.\n\n\nUser interface allows to assign convenience labels to subaddresses.\n\n\nYou may want to organize your incoming funds into a streams like \"donations\", \"work\", etc.\n\n\nThis is similar to subaccounts in your bank account. There is a very important difference though.\n\n\nIn Monero funds don't really sit on public addresses. Public addresses are conceptually a gateway or a routing mechanism. Funds sit on the unspent outputs. Thus, a single transaction can aggregate and spent outputs from multiple addresses.\n\n\nWhy not multiple wallets?\n\n\nThe advantage over creating multiple wallets is that you only have a \nsingle seed\n to manage.\nAll subaddresses can be derived from the wallet seed.\n\n\nAdditionally, you conveniently manage your subaddresses within a single user interface.\n\n\nData structure\n\n\nSubaddress has a dedicated \"network byte\":\n\n\n\n\n\n\n\n\nIndex\n\n\nSize in bytes\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\nidentifies the network and address type; \n42\n - main chain; \n63\n - test chain\n\n\n\n\n\n\n\n\nOtherwise the data structure is the same as for \nstandard address\n.\n\n\nEach subaddress conceptually has an index (with 0 being the base standard address).\nThe index is not directly included in subaddress structure but is used as input to create the private spend key.\n\n\nCaveates\n\n\n\n\nSubaddress \ncannot\n be used to receive transactions having multiple destinations (e.g. pool payouts). Only the standard address (the one with index == 0) can receive such transactions.\n\n\nIt is not recommended to sweep all the balances of subaddress to main address in a single transaction. That links the subaddresses together on the blockchain. However, this only concerns privacy against specific sender and the situation will never get worse than not using subaddresses in the first place. If you need to join funds while preserving maximum privacy do it with individual transactions (one per subaddress).\n\n\nConvenience labels are not preserved when recreating from seed.\n\n\n\n\nReference\n\n\n\n\nhttps://github.com/monero-project/monero/pull/2056\n\n\nhttps://www.reddit.com/r/Monero/comments/5vgjs2/subaddresses_and_disposable_addresses/",
            "title": "Subaddress"
        },
        {
            "location": "/public-address/subaddress/#subaddress",
            "text": "!! This is unreleased feature !!  Subaddresses serve two purposes described below.",
            "title": "Subaddress"
        },
        {
            "location": "/public-address/subaddress/#prevent-payer-from-linking-your-payouts-together",
            "text": "To prevent the payer from linking your payouts together simply generate a new subaddress for each payout.\nThis way services like  Shapeshift  wouldn't know it is you again receving Monero.  Note it won't help if you have an account with the service. Then your payouts are already linked in the service database, regardless of Monero.",
            "title": "Prevent payer from linking your payouts together"
        },
        {
            "location": "/public-address/subaddress/#group-incoming-payments",
            "text": "Think income streams.  Subaddresses allow to group incoming transactions within a single wallet.  User interface allows to assign convenience labels to subaddresses.  You may want to organize your incoming funds into a streams like \"donations\", \"work\", etc.  This is similar to subaccounts in your bank account. There is a very important difference though.  In Monero funds don't really sit on public addresses. Public addresses are conceptually a gateway or a routing mechanism. Funds sit on the unspent outputs. Thus, a single transaction can aggregate and spent outputs from multiple addresses.",
            "title": "Group incoming payments"
        },
        {
            "location": "/public-address/subaddress/#why-not-multiple-wallets",
            "text": "The advantage over creating multiple wallets is that you only have a  single seed  to manage.\nAll subaddresses can be derived from the wallet seed.  Additionally, you conveniently manage your subaddresses within a single user interface.",
            "title": "Why not multiple wallets?"
        },
        {
            "location": "/public-address/subaddress/#data-structure",
            "text": "Subaddress has a dedicated \"network byte\":     Index  Size in bytes  Description      0  1  identifies the network and address type;  42  - main chain;  63  - test chain     Otherwise the data structure is the same as for  standard address .  Each subaddress conceptually has an index (with 0 being the base standard address).\nThe index is not directly included in subaddress structure but is used as input to create the private spend key.",
            "title": "Data structure"
        },
        {
            "location": "/public-address/subaddress/#caveates",
            "text": "Subaddress  cannot  be used to receive transactions having multiple destinations (e.g. pool payouts). Only the standard address (the one with index == 0) can receive such transactions.  It is not recommended to sweep all the balances of subaddress to main address in a single transaction. That links the subaddresses together on the blockchain. However, this only concerns privacy against specific sender and the situation will never get worse than not using subaddresses in the first place. If you need to join funds while preserving maximum privacy do it with individual transactions (one per subaddress).  Convenience labels are not preserved when recreating from seed.",
            "title": "Caveates"
        },
        {
            "location": "/public-address/subaddress/#reference",
            "text": "https://github.com/monero-project/monero/pull/2056  https://www.reddit.com/r/Monero/comments/5vgjs2/subaddresses_and_disposable_addresses/",
            "title": "Reference"
        },
        {
            "location": "/multisignature/",
            "text": "Multisignature\n\n\n!! This is unreleased feature !!\n\n\nIn cryptocurrencies, multisig feature allows to sign transaction with more than one private key. Funds protected with multisig can only be spent by signing with M-of-N keys.\n\n\nExample use cases:\n\n\n\n\nshared account (1-of-2; both husband and wife individually have full access to their funds)\n\n\nconsensus account (2-of-2; both husband and wife must agree to spend their funds)\n\n\nthreshold account (2-of-3; an escrow service is involved as an independent 3rd party, to co-sign with either the seller, or with the buyer, if seller and buyer do not agree)\n\n\nsecure account (2-of-3; a single owner controlls all 3 keys but secures them via a different means to diversify risks)\n\n\narbitrary threshold account (M-of-N; some cryptocurrencies provide full flexibility on the number of signers)\n\n\n\n\nMonero multisignature\n\n\nMonero doesn't directly implement multisignatures (at least not in a classical sense). Monero emulates the feature by secret splitting.\n\n\nTransactions are still signed with a single spend key. The spend key is a sum of all N private keys. The rationale for such design is to decouple multisig from ring signatures.\n\n\nLet's consider the 2-of-3 scheme. We have 3 participants. Each participant is granted exactly 2 private keys in a way that pairs do not repeat between participants. This way any 2 participants together have all 3 private keys required to create the private spend key.\n\n\nMulti-signing is a wallet-level feature. There is no way to learn from the blockchain which transactions were created using multiple signatures.\n\n\nIt is also worth noting in Monero there is no multisig addresses as such. \nAddress structure\n does not care how the underlying private spend key got created.\n\n\nIn Monero, only N-of-N and (N-1)-of-N multisignature schemes are supported. This covers all common scenarios mentioned above but does not allow for arbitrary voting (like \"3-of-5 board members\").\n\n\nAfter multisig wallet setup every participant ends up knowing the public address and private view key. This is necessary for participants to recognize and decipher transactions they are supposed to co-sign.\n\n\nMultisig wallet setup\n\n\nLet's consider a 2-of-3 scheme as it generalizes well. There will be three CLI wallet commands involved:\n\n\n1. prepare_multisig\n\n\nEvery participant independently generates \ninitialization data\n. This is \nnot\n an address.\n\n\nEvery participant sends his initialization data manually to all other participants over secure channel.\n\n\n2. make_multisig\n\n\nEvery participant applies initialization data from other participants. This results in a \nsecond round of initialization data\n. This is still \nnot\n an address.\n\n\nEvery participants sends his second round of init data to all other participants over secure channel.\n\n\n3. finalize_multisig\n\n\nEvery participant finalizes wallet creation by applying the second round of init data from all other participants. This finally results in a wallet \npublic address\n and \nprivate view key\n to be known for all participants. \n\n\nPlease note actions are symmetric for all participants. Even though we considered a 2-of-3 scheme, every participant cooperates with everyone else. The secret splitting is performed internally by the wallet.\n\n\nSecure sharing of initialization data between participants is manual. The wallet itself does not provide any secure communication channel. This is out of scope.\n\n\nReceiving funds\n\n\nAddress built by multisig setup is like any other address.\n\n\nYou can generate integrated addresses and subaddresses based on it.\n\n\nAll participants are able to see incoming funds as they share the private view key.\n\n\nWith a CLI, use the following commands to see incoming payments:\n\n\naddress\nrefresh\nshow_transfers\n\n\n\nSpending funds\n\n\nTODO\n\n\nReference\n\n\n\n\nhttps://monero.stackexchange.com/questions/5646/how-to-use-monero-multisignature-wallets-2-2-2-3",
            "title": "Multisignature"
        },
        {
            "location": "/multisignature/#multisignature",
            "text": "!! This is unreleased feature !!  In cryptocurrencies, multisig feature allows to sign transaction with more than one private key. Funds protected with multisig can only be spent by signing with M-of-N keys.  Example use cases:   shared account (1-of-2; both husband and wife individually have full access to their funds)  consensus account (2-of-2; both husband and wife must agree to spend their funds)  threshold account (2-of-3; an escrow service is involved as an independent 3rd party, to co-sign with either the seller, or with the buyer, if seller and buyer do not agree)  secure account (2-of-3; a single owner controlls all 3 keys but secures them via a different means to diversify risks)  arbitrary threshold account (M-of-N; some cryptocurrencies provide full flexibility on the number of signers)",
            "title": "Multisignature"
        },
        {
            "location": "/multisignature/#monero-multisignature",
            "text": "Monero doesn't directly implement multisignatures (at least not in a classical sense). Monero emulates the feature by secret splitting.  Transactions are still signed with a single spend key. The spend key is a sum of all N private keys. The rationale for such design is to decouple multisig from ring signatures.  Let's consider the 2-of-3 scheme. We have 3 participants. Each participant is granted exactly 2 private keys in a way that pairs do not repeat between participants. This way any 2 participants together have all 3 private keys required to create the private spend key.  Multi-signing is a wallet-level feature. There is no way to learn from the blockchain which transactions were created using multiple signatures.  It is also worth noting in Monero there is no multisig addresses as such.  Address structure  does not care how the underlying private spend key got created.  In Monero, only N-of-N and (N-1)-of-N multisignature schemes are supported. This covers all common scenarios mentioned above but does not allow for arbitrary voting (like \"3-of-5 board members\").  After multisig wallet setup every participant ends up knowing the public address and private view key. This is necessary for participants to recognize and decipher transactions they are supposed to co-sign.",
            "title": "Monero multisignature"
        },
        {
            "location": "/multisignature/#multisig-wallet-setup",
            "text": "Let's consider a 2-of-3 scheme as it generalizes well. There will be three CLI wallet commands involved:",
            "title": "Multisig wallet setup"
        },
        {
            "location": "/multisignature/#1-prepare_multisig",
            "text": "Every participant independently generates  initialization data . This is  not  an address.  Every participant sends his initialization data manually to all other participants over secure channel.",
            "title": "1. prepare_multisig"
        },
        {
            "location": "/multisignature/#2-make_multisig",
            "text": "Every participant applies initialization data from other participants. This results in a  second round of initialization data . This is still  not  an address.  Every participants sends his second round of init data to all other participants over secure channel.",
            "title": "2. make_multisig"
        },
        {
            "location": "/multisignature/#3-finalize_multisig",
            "text": "Every participant finalizes wallet creation by applying the second round of init data from all other participants. This finally results in a wallet  public address  and  private view key  to be known for all participants.   Please note actions are symmetric for all participants. Even though we considered a 2-of-3 scheme, every participant cooperates with everyone else. The secret splitting is performed internally by the wallet.  Secure sharing of initialization data between participants is manual. The wallet itself does not provide any secure communication channel. This is out of scope.",
            "title": "3. finalize_multisig"
        },
        {
            "location": "/multisignature/#receiving-funds",
            "text": "Address built by multisig setup is like any other address.  You can generate integrated addresses and subaddresses based on it.  All participants are able to see incoming funds as they share the private view key.  With a CLI, use the following commands to see incoming payments:  address\nrefresh\nshow_transfers",
            "title": "Receiving funds"
        },
        {
            "location": "/multisignature/#spending-funds",
            "text": "TODO",
            "title": "Spending funds"
        },
        {
            "location": "/multisignature/#reference",
            "text": "https://monero.stackexchange.com/questions/5646/how-to-use-monero-multisignature-wallets-2-2-2-3",
            "title": "Reference"
        }
    ]
}